算法说明
=============================

先看一下题目的来源及其分析：

* [陈利人出题的微博](http://weibo.com/1915548291/AcJcfgV0v)
* 陈利人的[参考分析](http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5ODIzNDQ3Mw==&appmsgid=10000279&itemidx=1&sign=3cae5f5182cc0a7c1bfc8d09ba4dbc3d)  
分析得很深入浅出 ：）

我的算法实现说明，在陈利人的[参考分析](http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5ODIzNDQ3Mw==&appmsgid=10000279&itemidx=1&sign=3cae5f5182cc0a7c1bfc8d09ba4dbc3d)上再加上一些细节：

1. 当出现相邻权重相等时，题目中没有约束，所以后面的小孩直接分1个糖果，这样可以分糖果数最小。
1. 扫描出权重的山坡信息（山坡=上坡+下坡），坡脚分一个糖，坡上一个糖一个糖递增或递减。  
对于上一条说到权重相等时，即处理成前一个山坡结束，新起一个山坡。
1. 连接的两个山坡：
    1. 通过权重相等新起的坡，2个坡没有重合的部分。
    1. 通过新上坡起的坡，坡脚是重合的，处理成后一个和减1，把重复计算了一次的坡脚校正了。
1. 上坡或下坡是等差数列(差值d=1，首项a1是1)，等差数列的求和公式sum = n * a1 + n * (n-1) * d / 2  
代入d=1,a1=1后，sum = n + n * (n-1) / 2 = n * (n+1) / 2（这是代码用的求和公式）。

复杂度分析
----------------------------------

一次正序遍历（一次遍历优化对于流式处理很重要），时间复杂度O(n)，空间复杂度O(1)（没有新开辟数据或使用栈）。
